---
title: Ethernaut Writeups Part-2
tags:
- technology
- blockchain
image: /images/ether/info.png
---

Continuing from challenge 6 of the Ethernaut!

<!--more-->

# Delegation

In this challenge we leaarn about delete method. It is a method used to call functions of other smart contracts. Lets look at the source code:

{%highlight text%}
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract Delegate {

  address public owner;

  constructor(address _owner) public {
    owner = _owner;
  }

  function pwn() public {
    owner = msg.sender;
  }
}

contract Delegation {

  address public owner;
  Delegate delegate;

  constructor(address _delegateAddress) public {
    delegate = Delegate(_delegateAddress);
    owner = msg.sender;
  }

  fallback() external {
    (bool result,) = address(delegate).delegatecall(msg.data);
    if (result) {
      this;
    }
  }
}
{%endhighlight%}

In the first contract we have been provided a function called "pwn()". We just need to call it throught the object of the second contract's instance. We can see here that the second contract first creates an object of the delegate contract and gives it's address as the parameter.  

Next we see a fallback function where it takes our data (that we control) and passes it to the delegate function call. Now we just need to call the fallback function with the "pwn()" as data. I still can't make sense of the last "if" block. Do not fret, for I have already posted it on stackoverflow.

Luckily we don't need the last if block to pass this challenge (It took me a while to figure it out). Here is what I did:

![](https://i.imgur.com/JEF8SCi.png)

![](https://i.imgur.com/gjfCNWs.png)

Lets understand what I did. First I called the "sendTransaction()" function with only the "data" parameter so as to trigger the fallback function. Next I gave the data parameter a value.

`web3.eth.abi.encodeFunctionSignature("pwn()")`

I tried to just do `{value:"pwn()"}` but it didn't work because the delegatecall() takes the input in an encoded format. Because we are using abi (application binary interface) We need to encode and decode values to interact with it. 

[I took help from here](https://medium.com/coinmonks/delegatecall-calling-another-contract-function-in-solidity-b579f804178c)

Author's note: [Case Study](https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7/)

Above article represents the technique we used in this level , which was used in second biggest eth hack of all time.

# Force

Even if you don't add **any** code to your smart contract it will be vulnerable. crazy right? That is exactly what this level was about. 

{%highlight text%}
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract Force {/*

                   MEOW ?
         /\_/\   /
    ____/ o o \
  /~____  =Ã¸= /
 (______)__m_m)

*/}
{%endhighlight%}

I read the hints and did some quick google to achieve our target, which was to increase this contracts balance from 0. We can forcefully add balance to a contract using 2 methods:

1. Add balance before deploying
2. selfDestruct one contract and send its balance to the target

We will use 2nd since the contract is already deployed. So I whip up a quick contract.

{%highlight text%}
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract yesMeow{
    address owner;
    receive() external payable{
        owner=msg.sender;
    }

    function boomGoesTheContract(address payable levelAddress) public{
        selfdestruct(levelAddress);
    }   
}
{%endhighlight%}

I first created a function to receive some ether. The receive function does it. We need to define it as external and payable. The code inside the function can be anything and it will still receive the ether and increase the balance of the contract.

Next we make a selfDestruct function and get some input from user. selfDestruct() takes a payable address as input. When it does destructs, it transfers all of its balance to the address that we give it.

Finally I deploy it. Give it some ether using metamask send button in the extension and then click the boom! button in Remix IDE.

Author's note: Do not rely on  `address(this).balance==0` to perform some action. Even if your contract doesn't receive ether it's balance can still be changed.

# Vault

Another easy challenge teaching us what I think is really important for any solidity developer to know. Private variables are **not** private! Lets see the source.

{%highlight text%}
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

contract Vault {
  bool public locked;
  bytes32 private password;

  constructor(bytes32 _password) public {
    locked = true;
    password = _password;
  }

  function unlock(bytes32 _password) public {
    if (password == _password) {
      locked = false;
    }
  }
}
{%endhighlight%}

So we have a private variable password and we need to somehow steal it to unlock the vault. Which is just making the "locked" variable go from true to false.

Doesn't look like there is anyway to do that. Until you read about private variables in solidity. They are not actually private and can be viewed by anyone. If it is private then it just means we won't be able to change it. 

![](https://i.imgur.com/PfC01lV.png)

The First we give the storage function the address of the contract and then give it another number which can be seen as an index. increasing it one by one will give us the value stored at that index!

![](https://i.imgur.com/i7LdFWA.png)

![](https://i.imgur.com/FnDiG5t.png)

Author's note: If we need to keep something private on blockchain then we need to encrypt it and never put the key on the chain. [zkSNARKs](https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/) provides a good way to determine if someone posses a secret parameter.